(* These tests have been generated by DeepSeek V3 *)

open Definitions
open Aux_propositional
open Nf
open Resolution_propositional
open Examples


let run_nf_tests () = 
    Printf.printf "=== Propositional Logic : Normal Form Tests ===\n";
    Printf.printf "NNF of %s: %s\n" (string_of_propositional_expr expr1) (string_of_propositional_expr (nnf expr1));
    Printf.printf "NNF of %s: %s\n" (string_of_propositional_expr expr2) (string_of_propositional_expr (nnf expr2));
    Printf.printf "NNF of %s: %s\n" (string_of_propositional_expr expr3) (string_of_propositional_expr (nnf expr3));
    Printf.printf "NNF of %s: %s\n" (string_of_propositional_expr expr4) (string_of_propositional_expr (nnf expr4));
    Printf.printf "Negation of %s: %s\n" (string_of_propositional_expr expr4) (string_of_propositional_expr (negate_propositional_expr expr4));
    Printf.printf "CNF of %s: %s\n" (string_of_propositional_expr expr4) (string_of_propositional_expr (cnf (nnf expr4)));
    Printf.printf "DNF of %s: %s\n" (string_of_propositional_expr expr4) (string_of_propositional_expr (dnf (nnf expr4)));
    Printf.printf "\n"


let run_resolution_propositional_tests () =
    Printf.printf "=== Propositional Logic : Resolution Tests ===\n";

    (* Test resolution_propositional *)
    let test_resolution expr name =
        Printf.printf "Testing: %s\n" name;
        Printf.printf "Formula: %s\n" (string_of_propositional_expr expr);
        
        let result = resolution_propositional expr in
        Printf.printf "Resolution result: %s\n" (if result then "SAT" else "UNSAT");
        
        let preprocessed = resolution_preprocessing expr in
        let clauses = cnf_clauses preprocessed in
        Printf.printf "Clauses after negating and transforming into CNF: ";
        List.iteri (fun i clause ->
            let clause_str = String.concat " ∨ " (List.map string_of_propositional_expr clause) in
            Printf.printf "%s%s" (if i > 0 then ", " else "") clause_str
        ) clauses;
        Printf.printf "\n\n"
    in

    (* Essential test cases *)
    test_resolution (And (Var "A", Neg (Var "A"))) "A ∧ ¬A (contradiction)";
    test_resolution (Implies (Var "A", Var "A")) "A → A (tautology)";
    test_resolution expr1 "A ∧ ¬B";
    test_resolution expr4 "(p ∧ (q → r)) → s";

    (* Test resolution steps *)
    Printf.printf "--- Resolution Steps Test ---\n";
    let test_expr = And (Or (Var "A", Var "B"), Or (Neg (Var "A"), Var "C")) in
    let preprocessed = resolution_preprocessing test_expr in
    let clauses = cnf_clauses preprocessed in
    Printf.printf "Formula: (A ∨ B) ∧ (¬A ∨ C)\n";
    Printf.printf "Clauses after negating and transforming into CNF:\n";
    List.iteri (fun i clause ->
        let clause_str = String.concat " ∨ " (List.map string_of_propositional_expr clause) in
        Printf.printf "  [%d] %s\n" (i+1) clause_str
    ) clauses;
    
    if List.length clauses >= 2 then
        let c1 = List.nth clauses 1 in
        let c2 = List.nth clauses 2 in
        let resolvents = find_resolvents c1 c2 in
        Printf.printf "Resolvent for clauses 1 and 2: ";
        if List.length resolvents = 0 then
            Printf.printf "None\n"
        else
            List.iteri (fun i res ->
                let res_str = String.concat " ∨ " (List.map string_of_propositional_expr res) in
                Printf.printf "%s%s" (if i > 0 then ", " else "") res_str
            ) resolvents;
        Printf.printf "\n"
    else
        Printf.printf "Not enough clauses\n";
    Printf.printf "\n"


let run_all_tests () =
    run_nf_tests ();
    run_resolution_propositional_tests ()


let () = run_all_tests ()
