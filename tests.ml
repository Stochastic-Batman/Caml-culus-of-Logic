open Definitions
open Aux_propositional
open Nf
open Resolution_propositional
open Sequent_calculus_propositional
open Tableaux_propositional
open Aux_first_order
open Clausification_first_order
open Unification_first_order
open Resolution_first_order
open Examples


(* These tests have been generated by DeepSeek V3 *)

(* Propositional Logic *)

let run_nf_tests () =
    Printf.printf "=== Propositional Logic : Normal Form Tests ===\n";
    Printf.printf "NNF of %s: %s\n" (string_of_propositional_expr expr1) (string_of_propositional_expr (nnf expr1));
    Printf.printf "NNF of %s: %s\n" (string_of_propositional_expr expr2) (string_of_propositional_expr (nnf expr2));
    Printf.printf "NNF of %s: %s\n" (string_of_propositional_expr expr3) (string_of_propositional_expr (nnf expr3));
    Printf.printf "NNF of %s: %s\n" (string_of_propositional_expr expr4) (string_of_propositional_expr (nnf expr4));
    Printf.printf "Negation of %s: %s\n" (string_of_propositional_expr expr4) (string_of_propositional_expr (negate_propositional_expr expr4));
    Printf.printf "CNF of %s: %s\n" (string_of_propositional_expr expr4) (string_of_propositional_expr (cnf (nnf expr4)));
    Printf.printf "DNF of %s: %s\n" (string_of_propositional_expr expr4) (string_of_propositional_expr (dnf (nnf expr4)));
    Printf.printf "\n"


let run_resolution_propositional_tests () =
    Printf.printf "=== Propositional Logic : Resolution Tests ===\n";

    (* Test resolution_propositional *)
    let test_resolution expr name =
        Printf.printf "Testing: %s\n" name;
        Printf.printf "Formula: %s\n" (string_of_propositional_expr expr);

        let result = resolution_propositional expr in
        Printf.printf "Resolution result: %s\n" (if result then "SAT" else "UNSAT");

        let preprocessed = resolution_preprocessing expr in
        let clauses = cnf_clauses preprocessed in
        Printf.printf "Clauses after negating and transforming into CNF: ";
        List.iteri (fun i clause ->
            let clause_str = String.concat " ∨ " (List.map string_of_propositional_expr clause) in
            Printf.printf "%s%s" (if i > 0 then ", " else "") clause_str
        ) clauses;
        Printf.printf "\n\n"
    in

    (* Essential test cases *)
    test_resolution (And (Var "A", Neg (Var "A"))) "A ∧ ¬A (contradiction)";
    test_resolution (Implies (Var "A", Var "A")) "A → A (tautology)";
    test_resolution expr1 "A ∧ ¬B";
    test_resolution expr4 "(p ∧ (q → r)) → s";

    (* Test resolution steps *)
    Printf.printf "--- Resolution Steps Test ---\n";
    let test_expr = And (Or (Var "A", Var "B"), Or (Neg (Var "A"), Var "C")) in
    let preprocessed = resolution_preprocessing test_expr in
    let clauses = cnf_clauses preprocessed in
    Printf.printf "Formula: (A ∨ B) ∧ (¬A ∨ C)\n";
    Printf.printf "Clauses after negating and transforming into CNF:\n";
    List.iteri (fun i clause ->
        let clause_str = String.concat " ∨ " (List.map string_of_propositional_expr clause) in
        Printf.printf "  [%d] %s\n" (i+1) clause_str
    ) clauses;

    if List.length clauses >= 2 then
        let c1 = List.nth clauses 1 in
        let c2 = List.nth clauses 2 in
        (* Use qualified name for propositional resolvents *)
        let resolvents = Resolution_propositional.find_resolvents c1 c2 in
        Printf.printf "Resolvent for clauses 1 and 2: ";
        if List.length resolvents = 0 then
            Printf.printf "None\n"
        else
            List.iteri (fun i res ->
                let res_str = String.concat " ∨ " (List.map string_of_propositional_expr res) in
                Printf.printf "%s%s" (if i > 0 then ", " else "") res_str
            ) resolvents;
        Printf.printf "\n"
    else
        Printf.printf "Not enough clauses\n";
    Printf.printf "\n"


let run_sequent_calculus_tests () =
  Printf.printf "=== Propositional Logic : Sequent Calculus Tests ===\n";

  let test_sequent formula name =
    Printf.printf "Testing: %s\n" name;
    Printf.printf "Formula: %s\n" (string_of_propositional_expr formula);

    let result = prove_formula formula in
    (match result with
     | Proved -> Printf.printf "Result: PROVED (valid)\n"
     | Failed _ -> Printf.printf "Result: FAILED (not valid)\n");
    Printf.printf "\n"
  in

  let test_general_sequent seq name =
    Printf.printf "Testing sequent: %s\n" name;
    Printf.printf "Sequent: %s\n" (string_of_propositional_sequent seq);

    let result = prove_sequent_top seq in
    (match result with
     | Proved -> Printf.printf "Result: PROVED\n"
     | Failed _ -> Printf.printf "Result: FAILED\n");
    Printf.printf "\n"
  in

  (* Test formula validity *)
  test_sequent (Implies (Var "A", Var "A")) "A → A (tautology)";
  test_sequent (Implies (And (Var "A", Var "B"), Var "A")) "A∧B → A (valid)";
  test_sequent (And (Var "A", Neg (Var "A"))) "A ∧ ¬A (contradiction)";

  (* Test examples from slides *)
  let slide_example = Implies (Implies (Var "p", Var "q"),
                              Implies (Neg (Var "q"), Neg (Var "p"))) in
  test_sequent slide_example "(p → q) → (¬q → ¬p)";

  (* Test general sequents *)
  test_general_sequent
    { antecedent = [Var "A"]; consequent = [Var "A"] }
    "A ⟶ A (axiom)";

  test_general_sequent
    { antecedent = [Var "A"; Var "B"]; consequent = [Var "A"] }
    "A, B ⟶ A";

  Printf.printf "\n"


let run_tableaux_tests () =
  Printf.printf "=== Propositional Logic : Tableaux Tests ===\n";

  let test_tableaux formula name =
    Printf.printf "Testing: %s\n" name;
    Printf.printf "Formula: %s\n" (string_of_propositional_expr formula);

    (* Test semantic tableaux *)
    let semantic_result = complete_semantic_tableaux_propositional formula in
    Printf.printf "Semantic Tableaux: ";
    (match semantic_result with
     | TableauClosed -> Printf.printf "CLOSED (unsatisfiable)\n"
     | TableauOpen valuation ->
        Printf.printf "OPEN (satisfiable)\n";
        Printf.printf "  Satisfying valuation: ";
        List.iter (fun (v, b) -> Printf.printf "%s=%b " v b) valuation;
        Printf.printf "\n"
     | TableauUnknown -> Printf.printf "UNKNOWN\n");

    (* Test analytic tableaux *)
    let analytic_result = analytic_tableaux_propositional formula in
    Printf.printf "Analytic Tableaux: ";
    (match analytic_result with
     | TableauClosed -> Printf.printf "CLOSED (unsatisfiable)\n"
     | TableauOpen _ -> Printf.printf "OPEN (satisfiable)\n"
     | TableauUnknown -> Printf.printf "UNKNOWN\n");

    (* Test proving by tableaux *)
    let proved = prove_by_tableaux formula in
    Printf.printf "Proved by tableaux: %s\n" (if proved then "VALID" else "NOT VALID");

    Printf.printf "\n"
  in

  (* Test cases from the PDF and examples *)
  test_tableaux tableaux_expr1 "¬((p → q) → (¬q → ¬p))";
  test_tableaux tableaux_expr2 "¬((p → q) ∧ (¬p → ¬q))";
  test_tableaux tableaux_expr3 "(p ∨ q) ∧ (¬p ∧ ¬q)";
  test_tableaux tableaux_expr4 "A → A";
  test_tableaux tableaux_expr5 "A ∧ ¬A";

  Printf.printf "\n"



(* First-Order Logic Tests *)

let run_first_order_tests () =
    Printf.printf "=== First-Order Logic Tests ===\n";

    (* Test term operations *)
    Printf.printf "--- Term Operations ---\n";
    Printf.printf "Term 1: %s\n" (string_of_term_first_order term1_first_order);
    Printf.printf "Term 2: %s\n" (string_of_term_first_order term2_first_order);
    Printf.printf "Term 3: %s\n" (string_of_term_first_order term3_first_order);
    Printf.printf "Term 4: %s\n" (string_of_term_first_order term4_first_order);

    Printf.printf "Variables in term 3: %s\n"
                 (String.concat ", " (vars_of_term_first_order term3_first_order));
    Printf.printf "\n";

    (* Test formula operations *)
    Printf.printf "--- Formula Operations ---\n";
    Printf.printf "Formula 1: %s\n" (string_of_formula_first_order formula1_first_order);
    Printf.printf "Formula 4: %s\n" (string_of_formula_first_order formula4_first_order);
    Printf.printf "Formula 6: %s\n" (string_of_formula_first_order formula6_first_order);
    Printf.printf "Formula 9: %s\n" (string_of_formula_first_order formula9_first_order);

    Printf.printf "Free variables in formula 6: %s\n"
                 (String.concat ", " (free_vars_first_order formula6_first_order));
    Printf.printf "Is formula 4 closed? %b\n" (is_closed_first_order formula4_first_order);
    Printf.printf "\n";

    (* Test unification *)
    Printf.printf "--- Unification Tests ---\n";

    let test_unification t1 t2 name =
        Printf.printf "Unifying %s and %s: "
                      (string_of_term_first_order t1) (string_of_term_first_order t2);
        match unify [(t1, t2)] with
        | Unifiable subst ->
            Printf.printf "SUCCESS\n";
            List.iter (fun (v, t) ->
                         Printf.printf " %s -> %s\n" v (string_of_term_first_order t)
                     ) subst
        | NotUnifiable msg ->
            Printf.printf "FAILED: %s\n" msg
    in

    test_unification (FOVar "x") (FOConst "a") "x with a";
    test_unification (FOVar "x") (FOVar "y") "x with y";
    test_unification
        (FOFunc("f", [FOVar "x"]))
        (FOFunc("f", [FOConst "a"]))
        "f(x) with f(a)";
    test_unification
        (FOFunc("f", [FOVar "x"; FOConst "b"]))
        (FOFunc("f", [FOConst "a"; FOVar "y"]))
        "f(x,b) with f(a,y)";
    Printf.printf "\n";

    (* Test clausification *)
    Printf.printf "--- Clausification Tests ---\n";

    let test_clausification formula name =
        Printf.printf "Clausifying: %s\n" name;
        Printf.printf "Original: %s\n" (string_of_formula_first_order formula);
        let clauses = clausify formula in
        Printf.printf "Clauses:\n";
        List.iteri (fun i clause ->
                       let clause_str = String.concat " ∨ " (List.map string_of_formula_first_order clause) in
                       Printf.printf " [%d] %s\n" (i+1) clause_str
                   ) clauses;
        Printf.printf "\n"
    in

    test_clausification clausify_example1 "∀x.∃y.Loves(x,y)";
    test_clausification clausify_example2 "∀x.Man(x) → ∃y.(Mortal(y) ∧ Man(y))";
    test_clausification clausify_example3 "∀x.(Human(x) ∧ Male(x)) → Man(x)";
    Printf.printf "\n"


let run_resolution_first_order_tests () =
    Printf.printf "=== First-Order Logic : Resolution Tests ===\n";

    let test_resolution formula name =
        Printf.printf "Testing: %s\n" name;
        Printf.printf "Formula: %s\n" (string_of_formula_first_order formula);

        (* Show clausified form *)
        let clauses = clausify formula in
        Printf.printf "Clauses:\n";
        List.iteri (fun i clause ->
            let clause_str = String.concat " ∨ " (List.map string_of_formula_first_order clause) in
            Printf.printf "  [%d] %s\n" (i+1) clause_str
        ) clauses;
        Printf.printf "\n"
    in

    (* Test cases *)
    test_resolution resolution_example1 "∀x.P(x)";
    test_resolution resolution_example2 "∃x.¬P(x)";
    test_resolution resolution_example3 "∀x.Man(x) → Man(socrates)";
    test_resolution resolution_example4 "(∀x.Man(x) → Mortal(x)) ∧ Man(socrates)";
    test_resolution resolution_example5 "∀x.∃y.Loves(x,y)";

    (* Unsatisfiable test cases *)
    Printf.printf "--- Unsatisfiable Formulas ---\n";
    test_resolution resolution_unsat1 "∀x.P(x) ∧ ∃x.¬P(x)";
    test_resolution resolution_unsat2 "Socrates mortality paradox";

    Printf.printf "\n"


let run_all_tests () =
    run_nf_tests ();
    run_resolution_propositional_tests ();
    run_sequent_calculus_tests ();
    run_tableaux_tests ();
    run_first_order_tests ();
    run_resolution_first_order_tests ()


let () = run_all_tests ()
